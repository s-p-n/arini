<!doctype html>
<html>
<head>
	<title>Associative-Map Implementation Benchmark</title>
</head>
<body>
	<h1>Associative-Map Implementation Benchmark</h1>
	<div>
		Size: <input type="number" id="size" value="100000" />
		<br>
		<button id="get">Get</button>
		<button id="set">Set</button>
		<button id="delete">Delete</button>
		<button id="iterate">Iterate</button>
		<button id="stop" disabled=true>Stop</button>
	</div>
	<div style="position:relative; height:500px">
		<canvas id="chart" width="1000" height="500"></canvas>
	</div>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.bundle.min.js"></script>
	<script>
		let ctx = document.getElementById("chart").getContext("2d");
		let chartDatasets = [];
		let myChart = new Chart(ctx, {
		    type: 'line',
		    data: {
		    	labels: [],
		        datasets: chartDatasets
		    },
		    options: {
		    	responsive: false
		    }
		});
		class Benchmark {
			constructor () {
				this.benchmarks = {};
			}

			start (name) {
				this.benchmarks[name] = {
					name: name,
					start: Date.now(),
					end: NaN,
					difference: NaN
				}
			}

			end (name) {
				this.benchmarks[name].end = Date.now();
				this.benchmarks[name].difference = this.benchmarks[name].end - this.benchmarks[name].start;
			}

			report (name) {
				if (name) {
					return this.benchmarks[name];
				}
				return this.benchmarks;
			}
		}

		class AssociativeMap {
			constructor (arr=[]) {
				let self = this;
				this.obj = Object.create(null);
				this.array = arr;

				for (let i = 0; i < arr.length; i += 1) {
					this.obj[arr[i][0]] = arr[i][1];
				}

				const iteratorObject = {
					next: function () {},
					[Symbol.iterator]: function () { return this; }
				};
				const iteratorData = {
					index: 0,
					result: {
						value: undefined,
						done: false
					}
				};

				function nextEntry () {
					if (this._data.index < self.size) {
						let key = self.getKey(this._data.index ++);
						this._data.result.value = [key, self.get(key)];
					} else {
						this._data.index = 0;
						return {done: true};
					}
					return this._data.result;
				}

				function nextKey () {
					if (this._data.index < self.size) {
						this._data.result.value = self.getKey(this._data.index ++);
					} else {
						this._data.index = 0;
						return {done: true};
					}
					return this._data.result;
				}

				function nextValue () {
					if (this._data.index < self.size) {
						this._data.result.value = self.get(self.getKey(this._data.index ++));
					} else {
						this._data.index = 0;
						return {done: true};
					}
					return this._data.result;
				}

				this._createEntryIterator = function _createEntryIterator () {
					return this._createIterator(nextEntry);
				}

				this._createKeyIterator = function _createKeyIterator () {
					return this._createIterator(nextKey);
				}

				this._createValueIterator = function _createValueIterator () {
					return this._createIterator(nextValue);
				}

				this._createIterator = function _createIterator (next) {
					let iterObj = Object.create(iteratorObject);
					iterObj._data = Object.create(iteratorData);
					iterObj.next = next;
					return iterObj;
				};
			}

			get (key) {
				return this.obj[key];
			}

			getKey (index) {
				return this.array[index];
			}

			getIndex (key) {
				return this.array.indexOf(key);
			}

			set (key, value) {
				if (this.has(key)) {
					return this.obj[key] = value;
				}
				this.array.push(key);
				this.obj[key] = value;
				return this.obj[key];
			}

			deleteKey (key) {
				delete this.obj[key];
			}

			deleteIndex (index) {
				if (index >= 0 && index < this.size) {
					this.array.splice(index, 1);
					return true;
				}
				return false;
			}

			delete (key) {
				if (this.has(key)) {
					this.deleteKey(key);
					return this.deleteIndex(this.getIndex(key));
				}
				return false;
			}

			clear () {
				this.size = 0;
			}

			entries () {
				return this._createEntryIterator();
			}

			keys () {
				return this._createKeyIterator();
			}

			values () {
				return this._createValueIterator();
			}

			has (key) {
				return (key in this.obj);
			}

			forEach (callback, thisArg=this) {
				for (let i = 0; i < this.size; i += 1) {
					let key = this.getKey(i);
					let val = this.get(key);
					callback.call(thisArg, val, key, this);
				}
			}

			get size () {
				return this.array.length;
			}

			set size (value) {
				if (value === 0) {
					this.obj = Object.create(null);
				} else if (value > -1 && value < (this.size - 1)) {
					for (let i = value; i < this.size; i += 1) {
						this.deleteKey(this.array[i]);
					}
				} else {
					return false;
				}
				return this.array.length = value;
			}

			[Symbol.iterator] () {
				return this._createEntryIterator();
			}
		}

		let mapSize = 100000;
		let b = new Benchmark();
		let m = new Map();
		let fm = new AssociativeMap();
		let keys = [];
		function createPsuedoObjKeys (size) {
			let allowedChars = "abcdefghijklmnopkrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
			let len = allowedChars.length;
			let keySize = [5, 15];
			let result = new Array(size);
			while(result.length < size) {
				let s = Math.floor(Math.random() * (keySize[1] - keySize[0] + 1)) + keySize[0];
				let key = "";
				for (let i = 0; i < s; i += 1) {
					key += allowedChars[Math.floor(Math.random() * (len - s) + s)];
				}
				if (result.indexOf(key) === -1) {
					result.push(key);
				}
			}
			return result;
		}

		function initMap () {
			keys = createPsuedoObjKeys(mapSize);
			let mapArr = new Array(mapSize);
			for (let i = 0; i < mapSize; i += 1) {
				mapArr[i] = [keys[i], i + 1];
			}
			fm = new AssociativeMap(mapArr);
			m = new Map(mapArr);
		}

		function mapDeletion (id) {
			let map = m;
			if (map.delete(id)) {
				if (id === map.size) {
					//console.log("fast delete");
					return true;
				}
				//console.log("renumber map");
				let i = 0;
				let stop = map.size + 0;
				for (let i = id; i < stop; i += 1) {
					//console.log(map);
					let val = map.get(i + 1);
					map.delete(i + 1);
					map.set(i, val);
				}
				return true;
			} else {
				return false;
			}
		}
		
		function fmDeletion (id) {
			fm.delete(id);
		}
		
		let stop = true;
		function postStop () {
			sizeInput.disabled = false;
			getBtn.disabled = false;
			setBtn.disabled = false;
			deleteBtn.disabled = false;
			iterateBtn.disabled = false;
			stopBtn.disabled = true;
		}
		function postStart () {
			chartDatasets.length = 0;
			sizeInput.disabled = true;
			getBtn.disabled = true;
			setBtn.disabled = true;
			deleteBtn.disabled = true;
			iterateBtn.disabled = true;
			stopBtn.disabled = false;
			myChart.data.labels.length = 0;
			stop = false;
		}
		function runDelete () {
			let step = 10000;
			let innerStep = 0;
			function intervalFunc(id) {
				if (id >= mapSize || stop) {
					postStop();
					return;
				}
				let key = keys[id]; 
				switch (innerStep) {
					case 0:
						b.start('map');
						mapDeletion(key);
						b.end('map');
						break;
					case 1:
						b.start('array');
						fmDeletion(key);
						b.end('array');
						break;
					default:
						let result = b.report();
						chartDatasets[0].data.push({x: id, y: result.array.difference});
						chartDatasets[1].data.push({x: id, y: result.map.difference});
						myChart.data.labels.push(id);
						myChart.update({duration: 0});
						initMap();
						id += step;
				}
				innerStep += 1;
				if (innerStep > 2) {
					innerStep = 0;
				}
				//console.log("updated:", newData, iterData);
				window.requestAnimationFrame(() => {
					intervalFunc(id);
				});
			};
			postStart();
			chartDatasets.push({
				label: "Array Wrapper",
				borderColor: "#0000FF",
				backgroundColor: "rgba(0, 0, 255, 0.1)",
				data: []
			},
			{
				label: "Builtin Map",
				borderColor: "#00FF00",
				backgroundColor: "rgba(255, 0, 0, 0.1)",
				data: []
			});
			initMap();
			window.requestAnimationFrame(() => {
				intervalFunc(0);
			});
		}

		function runGet () {
			let step = 10000;
			let innerStep = 0;
			function intervalFunc (id) {
				if (id >= mapSize || stop) {
					postStop();
					return;
				}
				switch(innerStep) {
					case 0:
						b.start('map');
						for (let i = id; i < id + step; i += 1) {
							m.get(keys[i]);
						}
						b.end('map');
						break;
					case 1:
						b.start('array');
						for (let i = id; i < id + step; i += 1) {
							fm.get(keys[i]);
						}
						b.end('array');
						break;
					default:
						let result = b.report();
						chartDatasets[0].data.push({x: id, y: result.array.difference});
						chartDatasets[1].data.push({x: id, y: result.map.difference});
						myChart.data.labels.push(id);
						myChart.update({duration: 0});
						initMap();
						id += step;
				}
				innerStep += 1;
				if (innerStep > 2) {
					innerStep = 0;
				}
				//console.log("updated:", newData, iterData);
				window.requestAnimationFrame(() => {
					intervalFunc(id);
				});
			}
			postStart();
			chartDatasets.push({
				label: "Array Wrapper",
				borderColor: "#0000FF",
				backgroundColor: "rgba(0, 0, 255, 0.1)",
				data: []
			},
			{
				label: "Builtin Map",
				borderColor: "#00FF00",
				backgroundColor: "rgba(255, 0, 0, 0.1)",
				data: []
			});
			initMap();
			window.requestAnimationFrame(() => {
				intervalFunc(0);
			});
		}

		function runSet () {
			let step = 10000;
			let innerStep = 0;
			function intervalFunc (id) {
				if (id >= mapSize || stop) {
					postStop();
					return;
				}
				switch(innerStep) {
					case 0:
						b.start('map');
						for (let i = id; i < id + step; i += 1) {
							m.set(keys[i], "a");
						}
						b.end('map');
						break;
					case 1:
						b.start('array');
						for (let i = id; i < id + step; i += 1) {
							fm.set(keys[i], "a");
						}
						b.end('array');
						break;
					default:
						let result = b.report();
						chartDatasets[0].data.push({x: id, y: result.array.difference});
						chartDatasets[1].data.push({x: id, y: result.map.difference});
						myChart.data.labels.push(id);
						myChart.update({duration: 0});
						initMap();
						id += step;
				}
				innerStep += 1;
				if (innerStep > 2) {
					innerStep = 0;
				}
				//console.log("updated:", newData, iterData);
				window.requestAnimationFrame(() => {
					intervalFunc(id);
				});
			}
			postStart();
			chartDatasets.push({
				label: "Array Wrapper",
				borderColor: "#0000FF",
				backgroundColor: "rgba(0, 0, 255, 0.1)",
				data: []
			},
			{
				label: "Builtin Map",
				borderColor: "#00FF00",
				backgroundColor: "rgba(255, 0, 0, 0.1)",
				data: []
			});
			initMap();
			window.requestAnimationFrame(() => {
				intervalFunc(0);
			});
		}

		function runIterate () {
			let originalSize = mapSize;
			let step = 10000;
			let innerStep = 0;

			function intervalFunc () {
				let id = mapSize;
				if (mapSize >= originalSize || stop) {
					mapSize = originalSize;
					postStop();
					return;
				}

				switch (innerStep) {
					/*case 0:
						b.start("map1");
						for (let [index, val] = [0, m.get(0)]; index < m.size; index += 1, val = m.get(key));
						b.end("map1");
						break;*/
					case 0:
						b.start("map");
						for (let [key, val] of m);
						b.end("map");
						break;
					case 1:
						b.start("array1");
						for (let index = 0, key = fm.getKey(0), val = fm.get(key); index < fm.size; index += 1, key = fm.getKey(index), val = fm.get(key));
						b.end("array1");
						break;
					case 2:
						b.start("array2");
						for (let [key, val] of fm);
						b.end("array2");
						break;
					default:
						let result = b.report();
						chartDatasets[0].data.push({x: id, y: result.array1.difference});
						chartDatasets[1].data.push({x: id, y: result.array2.difference});
						chartDatasets[2].data.push({x: id, y: result.map.difference});
						//chartDatasets[2].data.push({x: id, y: result.map1.difference});
						//chartDatasets[3].data.push({x: id, y: result.map2.difference});
						myChart.data.labels.push(id);
						myChart.update({duration: 0});
						mapSize += step;
						initMap();
				}
				innerStep += 1;
				if (innerStep > 3) {
					innerStep = 0;
				}
				//console.log("updated:", newData, iterData);
				window.requestAnimationFrame(intervalFunc);
			}

			postStart();
			chartDatasets.push({
				label: "Array Wrapper for(;;)",
				borderColor: "#0000FF",
				backgroundColor: "rgba(0, 0, 255, 0.1)",
				data: []
			}, {
				label: "Array Wrapper for(of)",
				borderColor: "#00FFFF",
				backgroundColor: "rgba(0, 255, 255, 0.1)",
				data: []
			},
			/*{
				label: "Builtin Map for(;;)",
				borderColor: "#FF0000",
				backgroundColor: "rgba(255, 0, 0, 0.1)",
				data: []
			},*/ {
				label: "Builtin Map Wrapper for(of)",
				borderColor: "#FFFF00",
				backgroundColor: "rgba(255, 255, 0, 0.1)",
				data: []
			});
			mapSize = 0;
			initMap();

			window.requestAnimationFrame(intervalFunc);

		}

		let sizeInput = document.getElementById('size');
		let getBtn = document.getElementById('get');
		let setBtn = document.getElementById('set');
		let deleteBtn = document.getElementById('delete');
		let iterateBtn = document.getElementById('iterate');
		let stopBtn = document.getElementById('stop');

		stopBtn.addEventListener('click', () => {
			stop = true;
		});

		sizeInput.addEventListener('keyup', function (e) {
			mapSize = parseInt(this.value);
		});
		getBtn.addEventListener('click', runGet);
		setBtn.addEventListener('click', runSet);
		deleteBtn.addEventListener('click', runDelete);
		iterateBtn.addEventListener('click', runIterate);


	</script>
</body>
</html>
