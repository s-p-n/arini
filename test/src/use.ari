let tests = [{
	// Intended use:

	// A Person has a name, and can announce it.
	let Person {
		protected name = "Brian";
		public sayHi {
			return `Hello, my name is ${name}`;
		};
	};

	// A Spy is a Person who can change their name.
	let Spy {
		// When we use Person, 
		use Person;
		public setName (newName) {
			name = newName;
		};
	};

	let results = [];
	let p = Spy();
	results[] = (p.sayHi());
	p.setName("Steve");
	results[] = (p.sayHi());
	return results;
}(),
{
	// Cool, strange, or otherwise interesting stuff

	// Arini doesn't respect 'this' from JavaScript.
	// But, we can make our own 'this' !!
	let path = require('path');
	let GotThisLoader = scope.compile("./useLib/this.ari");
	//console.log(GotThisLoader);
	
	return async {
		let g = await GotThisLoader;

		// Implementation                              | Analogy to internal property creation:
		//--------------------------------------------------------------------------------------
		g.set('foo', 123);								// public foo = 123
		g.set('protected', 'theName', 'the value.');	// protected theName = 'the value.'
		g.set('get123', {return 123;});					// public get123 { return 123; }
		g.set('protected', 'bar');						// protected bar = undefined
		g.set('baz');									// public baz = undefined
		g.set('protected');								// do nothing
		g.set('public');								// do nothing
		g.set();										// do nothing
		//--------------------------------------------------------------------------------------

		//console.log(g); // just the public props: set, get, getAllProps, foo, get123, baz
		//console.log(g.getAllProps()); // an array with all the properties, organized like: [public: [...], protected: [...]]
		//console.log(g.theName); // undefined
		//console.log(g.get('theName')); // 'the value.'
		//console.log(g.get('foo')); // 123
		//console.log(g.get('non-existant')); // []
		//console.log(g is g.getAllProps()['public']); // true
		return g;
	}();
}()];
return await Promise.all(tests);