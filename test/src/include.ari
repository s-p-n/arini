/*
	This test demonstrates the use of build-level App I/O.

	Assume a directory structure like so:
	-------------------------------------
	project/
	- inc/
	- - foo.ari   (file to include)
	- include.ari (this file)
	-------------------------------------
	
	Assume the contents of 'inc/foo.ari':
	--------------------------------------
	public name = "Foo";
	--------------------------------------

	Assume running this command from the project directory:
		$ arini include.ari


	With the assumptions above, what does the code below do?
	---------------------------------------
	The property `foo` (below) becomes an instance of 'inc/foo.ari'
	The console would log [name: 'Foo']
	
	How does it work?
	---------------------------------------
	The include is carried out at compile-time.
	When the lexer see's an include expression,
	it replaces it with a scope containing the contents 
	of the file. If the file isn't accessible, then
	an error is thrown immediately- and the build 
	fails. 

	** The include operator is synchronous, and the lexer
	must wait for the file I/O, a new parser to be created/executed,
	and finally for the parser to output the compiled JavaScript
	from the included file in-place of the include statement.
	
	*** The include operator takes a static string. You may not use
	string interpolation, references, or anything otherwise dynamic.
	For dynamic, asynchronous, and runtime-level app I/O, see compile.ari

	The include below is converted into the file's contents wrapped in curly braces (a scope) and then invoked.
	So, essentially, 1st code-block becomes the 2nd code-block after included file is parsed.
	-----------------------------------------
	let foo = include "inc/foo.ari";
	-----------------------------------------
	let foo = {
		public name = "Foo";
	};
	------------------------------------------
*/
let a = 'b';
let foo = include "inc/foo.ari";

console.log(foo);